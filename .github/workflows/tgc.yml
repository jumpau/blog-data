name: TC

on:
  schedule:
    - cron: '0 */1 * * *'
  workflow_dispatch:

jobs:
  build:
    runs-on: self-hosted

    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: 18
        cache: 'yarn'
        
    - uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: ffmpeg chromium-browser
        version: 1.0

    - name: Create and activate venv, install dependencies
      run: |
        set -xe
        python3 -m venv venv
        source venv/bin/activate
        python3 -VV
        pip install telethon
        pip install --upgrade pip
        pip install git+https://github.com/jumpau/TBCCG.git
        yarn global add puppeteer-lottie-cli

    - name: Setup working directory
      run: |
        ls -lah
        echo "Working in main branch, files will be kept locally"
    
    - name: Run tgc
      env:
        tgc_config: ${{ secrets.TGC_CONFIG }}
        PYTHONUNBUFFERED: 1
      run: |
        source venv/bin/activate
        tgc
    
    - name: Zotero Download
      env:
        ZOTERO: ${{ secrets.ZOTERO_USERID }}
      if: "${{ env.ZOTERO != '' }}"
      run: |
        rm -rf zotero.json
        curl -L "https://api.zotero.org/users/${ZOTERO}/publications/items?linkwrap=1&order=date&sort=desc&start=0&include=data&limit=100" --output zotero.json
        ls -lah
        
    - name: Profile Readme Download
      env:
        REPO_NAME: ${{ github.repository }}
      run: |
        echo "$REPO_NAME"
        USER=$(python3 -c "print('${REPO_NAME}'.split('/')[0])")
        echo "$USER"
        rm -rf profile-readme.md
        if ! curl -L "https://raw.githubusercontent.com/${USER}/${USER}/main/README.md" --output profile-readme.md; then
          echo "Failed to download readme."
        fi
        ls -lah
        
    - name: List generated files
      run: |
        echo "Generated files are kept in the current directory:"
        ls -lah
        
    - name: Deploy to Cloudflare Pages
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        CLOUDFLARE_PROJECT_NAME: ${{ secrets.CLOUDFLARE_PROJECT_NAME }}
        tgc_config: ${{ secrets.TGC_CONFIG }}
      run: |
        # å®‰è£… toml è§£æåº“
        source venv/bin/activate
        pip install toml
        
        # ä½¿ç”¨Pythonè„šæœ¬æ¥è§£æé…ç½®å¹¶éƒ¨ç½²
        cat > deploy_script.py << 'EOF'
        import os
        import toml
        import json
        import shutil
        import subprocess
        from pathlib import Path
        
        # è§£æTGCé…ç½®
        config_str = os.environ.get('tgc_config', '')
        if not config_str:
            print("âŒ TGC_CONFIG ä¸ºç©º")
            exit(1)
        
        # å†™å…¥ä¸´æ—¶é…ç½®æ–‡ä»¶
        with open('temp_config.toml', 'w', encoding='utf-8') as f:
            f.write(config_str)
        
        try:
            config = toml.load('temp_config.toml')
            source_dir = ""
            if 'exports' in config and len(config['exports']) > 0:
                source_dir = config['exports'][0].get('path', '')
        except Exception as e:
            print(f"âŒ è§£æé…ç½®å¤±è´¥: {e}")
            source_dir = ""
        
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if os.path.exists('temp_config.toml'):
            os.remove('temp_config.toml')
        
        if not source_dir:
            print("âŒ æ— æ³•ä»é…ç½®ä¸­è·å–è¾“å‡ºè·¯å¾„ï¼Œä½¿ç”¨é»˜è®¤è·¯å¾„")
            source_dir = "../../../../../../../www/wwwroot/bk.cn"
        
        print(f"ğŸ“ ä½¿ç”¨è¾“å‡ºç›®å½•: {source_dir}")
        
        # ç›´æ¥ä½¿ç”¨æºç›®å½•è¿›è¡Œéƒ¨ç½²ï¼Œä¸åˆ›å»ºdeployå‰¯æœ¬
        source_path = Path(source_dir)
        print(f"=== æ£€æŸ¥æºç›®å½•: {source_path.absolute()} ===")
        
        # è¦æ£€æŸ¥çš„æ–‡ä»¶åˆ—è¡¨
        files_to_deploy = ['atom.xml', 'index.html', 'posts.json', 'rss.xml']
        available_files = []
        
        if source_path.exists():
            print("âœ“ æºç›®å½•å­˜åœ¨")
            for file_name in files_to_deploy:
                src_file = source_path / file_name
                if src_file.exists():
                    print(f"âœ“ æ‰¾åˆ°æ–‡ä»¶ {file_name} ({src_file.stat().st_size} bytes)")
                    available_files.append(file_name)
                else:
                    print(f"âœ— {file_name} ä¸å­˜åœ¨")
        else:
            print("âŒ æºç›®å½•ä¸å­˜åœ¨ï¼Œå°è¯•æŸ¥æ‰¾æ–‡ä»¶...")
            # æŸ¥æ‰¾æ–‡ä»¶
            for root, dirs, files in os.walk('.'):
                for file_name in files_to_deploy:
                    if file_name in files:
                        src_file = Path(root) / file_name
                        print(f"âœ“ æ‰¾åˆ°æ–‡ä»¶ {file_name} åœ¨ {src_file} ({src_file.stat().st_size} bytes)")
                        available_files.append(file_name)
                        # æ›´æ–°æºç›®å½•ä¸ºæ‰¾åˆ°æ–‡ä»¶çš„ç›®å½•
                        source_path = Path(root)
                        break
        
        if not available_files:
            print("âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ–‡ä»¶å¯ä»¥éƒ¨ç½²ï¼")
            exit(1)
        
        print(f"âœ… å‡†å¤‡éƒ¨ç½² {len(available_files)} ä¸ªæ–‡ä»¶: {', '.join(available_files)}")
        
        # å°†æºç›®å½•è·¯å¾„ä¼ é€’ç»™ä¸Šä¼ è„šæœ¬
        with open('source_path.txt', 'w') as f:
            f.write(str(source_path.absolute()))
        
        with open('available_files.json', 'w') as f:
            json.dump(available_files, f)
        EOF
        
        # è¿è¡Œéƒ¨ç½²è„šæœ¬
        python3 deploy_script.py
        
        # å¦‚æœæ‰¾åˆ°äº†æ–‡ä»¶ï¼Œåˆ™åˆ›å»ºä¸Šä¼ è„šæœ¬
        if [ -f "source_path.txt" ] && [ -f "available_files.json" ]; then
          echo "=== åˆ›å»ºå¹¶è¿è¡Œä¸Šä¼ è„šæœ¬ ==="
          
          # å®‰è£…ä¾èµ–
          npm install form-data
          
          # åˆ›å»ºç›´æ¥ä»æºç›®å½•ä¸Šä¼ çš„è„šæœ¬
          cat > upload.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const https = require('https');
        const FormData = require('form-data');
        
        const accountId = process.env.CLOUDFLARE_ACCOUNT_ID;
        const projectName = process.env.CLOUDFLARE_PROJECT_NAME;
        const apiToken = process.env.CLOUDFLARE_API_TOKEN;
        
        function uploadToPages() {
          return new Promise((resolve, reject) => {
            // è¯»å–æºç›®å½•è·¯å¾„å’Œå¯ç”¨æ–‡ä»¶åˆ—è¡¨
            const sourcePath = fs.readFileSync('source_path.txt', 'utf8').trim();
            const availableFiles = JSON.parse(fs.readFileSync('available_files.json', 'utf8'));
            
            console.log('ä»æºç›®å½•ä¸Šä¼ :', sourcePath);
            console.log('ä¸Šä¼ æ–‡ä»¶:', availableFiles);
            
            const form = new FormData();
            const manifest = {};
            
            // æ£€æŸ¥æ˜¯å¦æœ‰çœŸæ­£çš„ index.html æ–‡ä»¶
            let hasRealIndex = availableFiles.includes('index.html');
            
            // å¦‚æœæ²¡æœ‰ index.htmlï¼Œåˆ›å»ºä¸€ä¸ªç®€å•çš„å…¥å£é¡µé¢
            if (!hasRealIndex) {
              console.log('âš ï¸  æ²¡æœ‰æ‰¾åˆ° index.htmlï¼Œåˆ›å»ºä¸€ä¸ªç®€å•çš„å…¥å£é¡µé¢');
              const defaultHtml = [
                '<!DOCTYPE html>',
                '<html lang="zh-CN">',
                '<head>',
                '    <meta charset="UTF-8">',
                '    <meta name="viewport" content="width=device-width, initial-scale=1.0">',
                '    <title>Blog</title>',
                '</head>',
                '<body>',
                '    <h1>æ¬¢è¿è®¿é—®åšå®¢</h1>',
                '    <p>å…¶ä»–æ–‡ä»¶:</p>',
                '    <ul>',
                availableFiles.map(f => '        <li><a href="/' + f + '">' + f + '</a></li>').join('\n'),
                '    </ul>',
                '</body>',
                '</html>'
              ].join('\n');
              const indexPath = path.join(sourcePath, 'index.html');
              fs.writeFileSync(indexPath, defaultHtml);
              availableFiles.push('index.html');
              console.log('âœ… åˆ›å»ºäº†é»˜è®¤ index.html');
            } else {
              console.log('âœ… ä½¿ç”¨ç°æœ‰çš„ index.html æ–‡ä»¶');
            }
            
            availableFiles.forEach(file => {
              const filePath = path.join(sourcePath, file);
              const stats = fs.statSync(filePath);
              const hash = require('crypto').createHash('sha1').update(fs.readFileSync(filePath)).digest('hex');
              
              // ç¡®ä¿æ–‡ä»¶è·¯å¾„ä»¥ / å¼€å¤´ï¼Œä½†ä¸è¦é‡å¤
              const webPath = file.startsWith('/') ? file : '/' + file;
              manifest[webPath] = { hash, size: stats.size };
              
              // è®¾ç½®æ­£ç¡®çš„ MIME ç±»å‹
              let contentType = 'text/plain';
              if (file.endsWith('.html')) contentType = 'text/html; charset=utf-8';
              else if (file.endsWith('.xml')) contentType = 'application/xml; charset=utf-8';
              else if (file.endsWith('.json')) contentType = 'application/json; charset=utf-8';
              else if (file.endsWith('.css')) contentType = 'text/css; charset=utf-8';
              else if (file.endsWith('.js')) contentType = 'application/javascript; charset=utf-8';
              
              form.append('file', fs.createReadStream(filePath), { 
                filename: file,
                filepath: webPath,
                contentType: contentType
              });
              
              console.log('ğŸ“„ ' + file + ': ' + stats.size + ' bytes, hash: ' + hash.substring(0, 8) + '..., type: ' + contentType);
            });
            
            // æ·»åŠ  _headers æ–‡ä»¶æ¥ç¡®ä¿æ­£ç¡®çš„ MIME ç±»å‹
            const headersLines = [
              '/*',
              '  X-Frame-Options: DENY',
              '  X-XSS-Protection: 1; mode=block',
              '  X-Content-Type-Options: nosniff',
              '  Referrer-Policy: strict-origin-when-cross-origin',
              '',
              '/*.html',
              '  Content-Type: text/html; charset=utf-8',
              '',
              '/*.xml',
              '  Content-Type: application/xml; charset=utf-8',
              '',
              '/*.json',
              '  Content-Type: application/json; charset=utf-8',
              '',
              '/*.css',
              '  Content-Type: text/css; charset=utf-8',
              '',
              '/*.js',
              '  Content-Type: application/javascript; charset=utf-8'
            ];
            const headersContent = headersLines.join('\n');
            
            const headersHash = require('crypto').createHash('sha1').update(headersContent).digest('hex');
            manifest['/_headers'] = { hash: headersHash, size: Buffer.byteLength(headersContent, 'utf8') };
            form.append('file', Buffer.from(headersContent, 'utf8'), { 
              filename: '_headers',
              filepath: '/_headers',
              contentType: 'text/plain'
            });
            console.log('ğŸ“„ _headers: æ·»åŠ äº† MIME ç±»å‹é…ç½®');
            
            // æ·»åŠ  _redirects æ–‡ä»¶æ¥å¤„ç†è·¯ç”±
            const redirectsContent = '# Redirects for Cloudflare Pages\n/*    /index.html   404';
            const redirectsHash = require('crypto').createHash('sha1').update(redirectsContent).digest('hex');
            manifest['/_redirects'] = { hash: redirectsHash, size: Buffer.byteLength(redirectsContent, 'utf8') };
            form.append('file', Buffer.from(redirectsContent, 'utf8'), { 
              filename: '_redirects',
              filepath: '/_redirects',
              contentType: 'text/plain'
            });
            console.log('ğŸ“„ _redirects: æ·»åŠ äº†è·¯ç”±é…ç½®');
            
            // æ·»åŠ å¿…è¦çš„éƒ¨ç½²é…ç½®
            const deploymentMetadata = {
              branch: 'main',
              commit_hash: '',
              commit_message: 'Auto deployment from GitHub Actions',
              commit_dirty: 'false'
            };
            
            form.append('manifest', JSON.stringify(manifest));
            
            // æ·»åŠ éƒ¨ç½²å…ƒæ•°æ®ï¼ˆç¡®ä¿æ‰€æœ‰å€¼éƒ½æ˜¯å­—ç¬¦ä¸²ï¼‰
            Object.keys(deploymentMetadata).forEach(key => {
              const value = deploymentMetadata[key];
              if (value !== null && value !== undefined && value !== '') {
                const stringValue = String(value);
                form.append(key, stringValue);
                console.log('ğŸ”§ æ·»åŠ å…ƒæ•°æ®: ' + key + ' = "' + stringValue + '"');
              }
            });
            
            console.log('ğŸ“‹ Manifest:', JSON.stringify(manifest, null, 2));
            console.log('ğŸ”§ éƒ¨ç½²é…ç½®:', deploymentMetadata);
            
            const options = {
              hostname: 'api.cloudflare.com',
              path: '/client/v4/accounts/' + accountId + '/pages/projects/' + projectName + '/deployments',
              method: 'POST',
              headers: { 
                'Authorization': 'Bearer ' + apiToken,
                'User-Agent': 'GitHub-Actions-Deploy/1.0',
                ...form.getHeaders() 
              }
            };
            
            console.log('ğŸš€ å‘é€åˆ°ç”Ÿäº§ç¯å¢ƒ:', 'https://' + options.hostname + options.path);
            
            const req = https.request(options, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                console.log('ğŸ“Š çŠ¶æ€ç :', res.statusCode);
                console.log('ğŸ“‹ å“åº”å¤´:', JSON.stringify(res.headers, null, 2));
                
                try {
                  const response = JSON.parse(data);
                  if (res.statusCode === 200 || res.statusCode === 201) {
                    console.log('âœ… éƒ¨ç½²æˆåŠŸ!');
                    console.log('ğŸ†” éƒ¨ç½²ID:', response.result && response.result.id);
                    console.log('ğŸŒ ç¯å¢ƒ:', response.result && response.result.environment);
                    console.log('ğŸŒ é¢„è§ˆURL:', response.result && response.result.url);
                    console.log('ğŸ¯ ç”Ÿäº§URL: https://' + projectName + '.pages.dev');
                    
                    // è¾“å‡ºè¯¦ç»†çš„éƒ¨ç½²ä¿¡æ¯
                    if (response.result) {
                      console.log('ğŸ“¦ éƒ¨ç½²è¯¦æƒ…:');
                      console.log('  - é˜¶æ®µ:', (response.result.latest_stage && response.result.latest_stage.name) || 'unknown');
                      console.log('  - çŠ¶æ€:', (response.result.latest_stage && response.result.latest_stage.status) || 'unknown');
                      if (response.result.deployment_trigger) {
                        console.log('  - è§¦å‘å™¨:', JSON.stringify(response.result.deployment_trigger));
                      }
                      if (response.result.build_config) {
                        console.log('  - æ„å»ºé…ç½®:', JSON.stringify(response.result.build_config));
                      }
                    }
                    
                    // å¦‚æœæ˜¯é¢„è§ˆç¯å¢ƒï¼Œè¾“å‡ºæå‡åˆ°ç”Ÿäº§ç¯å¢ƒçš„ä¿¡æ¯
                    if (response.result && response.result.environment === 'preview') {
                      console.log('âš ï¸  å½“å‰éƒ¨ç½²åœ¨é¢„è§ˆç¯å¢ƒï¼Œå¯èƒ½éœ€è¦åœ¨ Cloudflare æ§åˆ¶å°æ‰‹åŠ¨æå‡åˆ°ç”Ÿäº§ç¯å¢ƒ');
                      console.log('ğŸ”— æˆ–è€…æ£€æŸ¥é¡¹ç›®çš„ç”Ÿäº§åˆ†æ”¯è®¾ç½®');
                    }
                    
                    resolve(data);
                  } else {
                    console.error('âŒ éƒ¨ç½²å¤±è´¥:', res.statusCode);
                    console.error('ğŸ“‹ å®Œæ•´å“åº”:', data);
                    if (response.errors) {
                      console.error('ğŸš« é”™è¯¯è¯¦æƒ…:', JSON.stringify(response.errors, null, 2));
                      // åˆ†æå…·ä½“é”™è¯¯
                      response.errors.forEach((error, index) => {
                        console.error('é”™è¯¯ ' + (index + 1) + ':', error.message || error);
                        if (error.code) console.error('  é”™è¯¯ä»£ç :', error.code);
                      });
                    }
                    reject(new Error('Deploy failed: ' + res.statusCode));
                  }
                } catch (e) {
                  console.error('âŒ è§£æå“åº”å¤±è´¥:', e.message);
                  console.error('ğŸ“„ åŸå§‹å“åº”:', data);
                  reject(e);
                }
              });
            });
            
            req.on('error', (error) => {
              console.error('ğŸš« è¯·æ±‚é”™è¯¯:', error);
              reject(error);
            });
            
            form.pipe(req);
          });
        }
        
        uploadToPages().catch(console.error);
        EOF
          
          # è¿è¡Œä¸Šä¼ 
          node upload.js
          
          # æ¸…ç†ä¸´æ—¶æ–‡ä»¶ï¼ˆä½†ä¿ç•™åŸæ–‡ä»¶ï¼‰
          rm -f source_path.txt available_files.json
          echo "âœ… ä¸Šä¼ å®Œæˆï¼ŒåŸæ–‡ä»¶å·²ä¿ç•™åœ¨æºç›®å½•ä¸­"
        else
          echo "âŒ æ²¡æœ‰æ–‡ä»¶å¯ä»¥éƒ¨ç½²"
        fi
        
    - name: Verify files after upload
      run: |
        source venv/bin/activate
        python3 << 'EOF'
        import os
        import toml
        from pathlib import Path
        
        # é‡æ–°è§£æé…ç½®è·å–æºç›®å½•
        config_str = os.environ.get('tgc_config', '')
        if config_str:
            with open('temp_config.toml', 'w', encoding='utf-8') as f:
                f.write(config_str)
            try:
                config = toml.load('temp_config.toml')
                source_dir = ""
                if 'exports' in config and len(config['exports']) > 0:
                    source_dir = config['exports'][0].get('path', '')
                
                if source_dir:
                    source_path = Path(source_dir)
                    print(f"âœ… éªŒè¯æºç›®å½•æ–‡ä»¶çŠ¶æ€: {source_path.absolute()}")
                    files_to_check = ['atom.xml', 'index.html', 'posts.json', 'rss.xml']
                    for file_name in files_to_check:
                        file_path = source_path / file_name
                        if file_path.exists():
                            print(f"âœ“ {file_name} ä»ç„¶å­˜åœ¨ ({file_path.stat().st_size} bytes)")
                        else:
                            print(f"âœ— {file_name} ä¸å­˜åœ¨")
            except Exception as e:
                print(f"éªŒè¯æ—¶è§£æé…ç½®å¤±è´¥: {e}")
            finally:
                if os.path.exists('temp_config.toml'):
                    os.remove('temp_config.toml')
        EOF
