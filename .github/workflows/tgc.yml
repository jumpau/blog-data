name: TC

on:
  schedule:
    - cron: '0 */1 * * *'
  workflow_dispatch:

jobs:
  build:
    runs-on: self-hosted

    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: 18
        cache: 'yarn'
        
    - uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: ffmpeg chromium-browser
        version: 1.0

    - name: Create and activate venv, install dependencies
      run: |
        set -xe
        python3 -m venv venv
        source venv/bin/activate
        python3 -VV
        pip install telethon
        pip install --upgrade pip
        pip install git+https://github.com/jumpau/TBCCG.git
        yarn global add puppeteer-lottie-cli

    - name: Setup working directory
      run: |
        ls -lah
        echo "Working in main branch, files will be kept locally"
    
    - name: Run tgc
      env:
        tgc_config: ${{ secrets.TGC_CONFIG }}
        PYTHONUNBUFFERED: 1
      run: |
        source venv/bin/activate
        tgc
    
    - name: Zotero Download
      env:
        ZOTERO: ${{ secrets.ZOTERO_USERID }}
      if: "${{ env.ZOTERO != '' }}"
      run: |
        rm -rf zotero.json
        curl -L "https://api.zotero.org/users/${ZOTERO}/publications/items?linkwrap=1&order=date&sort=desc&start=0&include=data&limit=100" --output zotero.json
        ls -lah
        
    - name: Profile Readme Download
      env:
        REPO_NAME: ${{ github.repository }}
      run: |
        echo "$REPO_NAME"
        USER=$(python3 -c "print('${REPO_NAME}'.split('/')[0])")
        echo "$USER"
        rm -rf profile-readme.md
        if ! curl -L "https://raw.githubusercontent.com/${USER}/${USER}/main/README.md" --output profile-readme.md; then
          echo "Failed to download readme."
        fi
        ls -lah
        
    - name: List generated files
      run: |
        echo "Generated files are kept in the current directory:"
        ls -lah
        
    - name: Deploy to Cloudflare Pages
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        CLOUDFLARE_PROJECT_NAME: ${{ secrets.CLOUDFLARE_PROJECT_NAME }}
        tgc_config: ${{ secrets.TGC_CONFIG }}
      run: |
        # 安装 toml 解析库
        source venv/bin/activate
        pip install toml
        
        # 使用Python脚本来解析配置并部署
        cat > deploy_script.py << 'EOF'
        import os
        import toml
        import json
        import shutil
        import subprocess
        from pathlib import Path
        
        # 解析TGC配置
        config_str = os.environ.get('tgc_config', '')
        if not config_str:
            print("❌ TGC_CONFIG 为空")
            exit(1)
        
        # 写入临时配置文件
        with open('temp_config.toml', 'w', encoding='utf-8') as f:
            f.write(config_str)
        
        try:
            config = toml.load('temp_config.toml')
            source_dir = ""
            if 'exports' in config and len(config['exports']) > 0:
                source_dir = config['exports'][0].get('path', '')
        except Exception as e:
            print(f"❌ 解析配置失败: {e}")
            source_dir = ""
        
        # 清理临时文件
        if os.path.exists('temp_config.toml'):
            os.remove('temp_config.toml')
        
        if not source_dir:
            print("❌ 无法从配置中获取输出路径，使用默认路径")
            source_dir = "../../../../../../../www/wwwroot/bk.cn"
        
        print(f"📁 使用输出目录: {source_dir}")
        
        # 直接使用源目录进行部署，不创建deploy副本
        source_path = Path(source_dir)
        print(f"=== 检查源目录: {source_path.absolute()} ===")
        
        # 要检查的文件列表
        files_to_deploy = ['atom.xml', 'index.html', 'posts.json', 'rss.xml']
        available_files = []
        
        if source_path.exists():
            print("✓ 源目录存在")
            for file_name in files_to_deploy:
                src_file = source_path / file_name
                if src_file.exists():
                    print(f"✓ 找到文件 {file_name} ({src_file.stat().st_size} bytes)")
                    available_files.append(file_name)
                else:
                    print(f"✗ {file_name} 不存在")
        else:
            print("❌ 源目录不存在，尝试查找文件...")
            # 查找文件
            for root, dirs, files in os.walk('.'):
                for file_name in files_to_deploy:
                    if file_name in files:
                        src_file = Path(root) / file_name
                        print(f"✓ 找到文件 {file_name} 在 {src_file} ({src_file.stat().st_size} bytes)")
                        available_files.append(file_name)
                        # 更新源目录为找到文件的目录
                        source_path = Path(root)
                        break
        
        if not available_files:
            print("❌ 没有找到任何文件可以部署！")
            exit(1)
        
        print(f"✅ 准备部署 {len(available_files)} 个文件: {', '.join(available_files)}")
        
        # 将源目录路径传递给上传脚本
        with open('source_path.txt', 'w') as f:
            f.write(str(source_path.absolute()))
        
        with open('available_files.json', 'w') as f:
            json.dump(available_files, f)
        EOF
        
        # 运行部署脚本
        python3 deploy_script.py
        
        # 如果找到了文件，则创建上传脚本
        if [ -f "source_path.txt" ] && [ -f "available_files.json" ]; then
          echo "=== 创建并运行上传脚本 ==="
          
          # 安装依赖
          npm install form-data
          
          # 创建直接从源目录上传的脚本
          cat > upload.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const https = require('https');
        const FormData = require('form-data');
        
        const accountId = process.env.CLOUDFLARE_ACCOUNT_ID;
        const projectName = process.env.CLOUDFLARE_PROJECT_NAME;
        const apiToken = process.env.CLOUDFLARE_API_TOKEN;
        
        function uploadToPages() {
          return new Promise((resolve, reject) => {
            // 读取源目录路径和可用文件列表
            const sourcePath = fs.readFileSync('source_path.txt', 'utf8').trim();
            const availableFiles = JSON.parse(fs.readFileSync('available_files.json', 'utf8'));
            
            console.log('从源目录上传:', sourcePath);
            console.log('上传文件:', availableFiles);
            
            const form = new FormData();
            const manifest = {};
            
            // 确保有 index.html 作为入口文件
            if (!availableFiles.includes('index.html')) {
              console.log('⚠️  没有找到 index.html，创建一个简单的入口页面');
              const defaultHtml = `<!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Blog</title>
        </head>
        <body>
            <h1>欢迎访问博客</h1>
            <p>其他文件:</p>
            <ul>
                ${availableFiles.map(f => `<li><a href="/${f}">${f}</a></li>`).join('\n                ')}
            </ul>
        </body>
        </html>`;
              const indexPath = path.join(sourcePath, 'index.html');
              fs.writeFileSync(indexPath, defaultHtml);
              availableFiles.push('index.html');
              console.log('✅ 创建了默认 index.html');
            }
            
            availableFiles.forEach(file => {
              const filePath = path.join(sourcePath, file);
              const stats = fs.statSync(filePath);
              const hash = require('crypto').createHash('sha1').update(fs.readFileSync(filePath)).digest('hex');
              
              manifest[`/${file}`] = { hash, size: stats.size };
              form.append('file', fs.createReadStream(filePath), { filename: file, filepath: `/${file}` });
              
              console.log(`📄 ${file}: ${stats.size} bytes, hash: ${hash.substring(0, 8)}...`);
            });
            
            // 添加必要的部署配置
            const deploymentMetadata = {
              branch: 'main',
              commit_hash: '',
              commit_message: 'Auto deployment from GitHub Actions',
              commit_dirty: 'false'  // 改为字符串
            };
            
            form.append('manifest', JSON.stringify(manifest));
            
            // 添加部署元数据（只添加非空字符串）
            Object.keys(deploymentMetadata).forEach(key => {
              const value = deploymentMetadata[key];
              if (value !== '') {
                form.append(key, String(value));  // 确保转换为字符串
              }
            });
            
            console.log('📋 Manifest:', JSON.stringify(manifest, null, 2));
            console.log('🔧 部署配置:', deploymentMetadata);
            
            const options = {
              hostname: 'api.cloudflare.com',
              path: `/client/v4/accounts/${accountId}/pages/projects/${projectName}/deployments`,
              method: 'POST',
              headers: { 
                'Authorization': `Bearer ${apiToken}`,
                'User-Agent': 'GitHub-Actions-Deploy/1.0',
                ...form.getHeaders() 
              }
            };
            
            console.log('🚀 发送到生产环境:', `https://${options.hostname}${options.path}`);
            
            const req = https.request(options, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                console.log('📊 状态码:', res.statusCode);
                console.log('📋 响应头:', JSON.stringify(res.headers, null, 2));
                
                try {
                  const response = JSON.parse(data);
                  if (res.statusCode === 200 || res.statusCode === 201) {
                    console.log('✅ 部署成功!');
                    console.log('🆔 部署ID:', response.result?.id);
                    console.log('🌍 环境:', response.result?.environment);
                    console.log('🌐 预览URL:', response.result?.url);
                    console.log('� 生产URL: https://' + projectName + '.pages.dev');
                    
                    // 如果是预览环境，输出提升到生产环境的信息
                    if (response.result?.environment === 'preview') {
                      console.log('⚠️  当前部署在预览环境，可能需要在 Cloudflare 控制台手动提升到生产环境');
                      console.log('🔗 或者检查项目的生产分支设置');
                    }
                    
                    resolve(data);
                  } else {
                    console.error('❌ 部署失败:', res.statusCode);
                    console.error('📋 完整响应:', data);
                    if (response.errors) {
                      console.error('🚫 错误详情:', JSON.stringify(response.errors, null, 2));
                    }
                    reject(new Error(`Deploy failed: ${res.statusCode}`));
                  }
                } catch (e) {
                  console.error('❌ 解析响应失败:', e.message);
                  console.error('📄 原始响应:', data);
                  reject(e);
                }
              });
            });
            
            req.on('error', (error) => {
              console.error('🚫 请求错误:', error);
              reject(error);
            });
            
            form.pipe(req);
          });
        }
        
        uploadToPages().catch(console.error);
        EOF
          
          # 运行上传
          node upload.js
          
          # 清理临时文件
          rm -f source_path.txt available_files.json
        else
          echo "❌ 没有文件可以部署"
        fi
